diff --git a/includes/smart_paging.admin.inc b/includes/smart_paging.admin.inc
index ef33797..a695691 100644
--- a/includes/smart_paging.admin.inc
+++ b/includes/smart_paging.admin.inc
@@ -45,9 +45,15 @@ function smart_paging_admin_settings($form, &$form_state) {
     '#type'          => 'checkbox',
     '#title'         => t('Pagination with rel="next" and rel="prev" (!details)', array('!details' => l(t('more details'), 'http://googlewebmastercentral.blogspot.co.uk/2011/09/pagination-with-relnext-and-relprev.html'))),
     '#default_value' => variable_get('smart_paging_use_link_rel', TRUE),
-    '#description'   => t('This will remove the rel="canonical" link.'),
+    '#description'   => t('This adds next and prev hints according to Google pagination policies, see link.'),
   );
-  // Container for default values
+  $form['smart_paging_use_nopaging_canonical'] = array(
+    '#type'          => 'checkbox',
+    '#title'         => t('Use the unpaged version as canonical'),
+    '#default_value' => variable_get('smart_paging_use_nopaging_canonical', FALSE),
+    '#description'   => t('Use {page one}?nopaging=1 as the canonical link for all pages.'),
+   );
+   // Container for default values
   $form['smart_paging_defaults'] = array(
     '#type'        => 'fieldset',
     '#title'       => t('Default values'),
diff --git a/smart_paging.module b/smart_paging.module
index b39c1fe..4611eac 100644
--- a/smart_paging.module
+++ b/smart_paging.module
@@ -685,8 +685,28 @@ function smart_paging_field_attach_view_alter(&$build, $context) {
             // Default this to 'no method' if it's being called as a full page
             $query_parameters = drupal_get_query_parameters();
             if (isset($query_parameters['nopaging'])) {
-              // Prevent this page from being cached
-              $GLOBALS['conf']['cache'] = FALSE;
+              //Somewhat duplicated from below pagination code. Refactor candidate.
+              //Build url representation of current page. Using an absolute url allows outbound url hooks to modify the domain if necessary (domain module).
+              $current_absolute_alias = url($_GET['q'], array('absolute' => TRUE));
+              //Do we want nopaging as canonical instead of current page?
+              if (variable_get('smart_paging_use_nopaging_canonical', FALSE)) {
+                $link_current_page = $current_absolute_alias . '?nopaging=1';
+              }
+              //No. Make current paginated page canonical.
+              else {
+                $link_current_page = $current_absolute_alias;
+              }
+              //by default add a canonical head element here. We will clean up any duplicates in the hook.
+              drupal_add_html_head(array(
+                '#attributes' => array(
+                'rel'  => 'canonical',
+                'href' => $link_current_page,
+                  ),
+                '#tag' => 'link',
+               '#attached' => array(
+                      'drupal_add_http_header' => array(array('Link', '<' . $link_current_page . '>; rel="canonical"', 1)),
+                  ),
+              ), 'smart_paging_link_canonical');
               // If set, use "Convert line breaks into HTML" filter
               if (isset($use_autop)) {
                 $build[$field_name][$delta]['#markup'] = _filter_autop($markup_content);
@@ -855,27 +875,22 @@ function smart_paging_field_attach_view_alter(&$build, $context) {
           preg_match_all('#<!--smartpagingmeta [[:punct:][:alnum:][:space:]]*-->#', $sub_content, $matched_tags);
           if (!empty($matched_tags[0])) {
             $smart_paging_seo = preg_replace('#<!--smartpagingmeta |<!--smartpagingurl [[:punct:][:alnum:][:space:]]*-->|-->#', '', $matched_tags[0][0]);
-            drupal_add_html_head(array(
-              '#attributes' => array(
-                'name'		=> 'Smart_Paging',
-                'content' => $smart_paging_seo,
-              ),
-              '#tag' => 'meta'
-            ), 'smart_paging_seo');
-            // Call this function to register the additional html head
-            drupal_get_html_head();
+            if (!module_exists('metatag')) {
+              drupal_add_html_head(array(
+                '#attributes' => array(
+                  'name'		=> 'Smart_Paging',
+                  'content' => $smart_paging_seo,
+                ),
+                '#tag' => 'meta'
+              ), 'smart_paging_seo');
+              // Call this function to register the additional html head
+              drupal_get_html_head();
+            }
+            else {
+              $output = &drupal_static('smart_paging');
+              $output = json_decode($smart_paging_seo, TRUE);
+            }
           }
-          // Add smart_paging_on as indicator to hook_html_head_alter() that
-          // Smart Paging is applied to this page
-          drupal_add_html_head(array(
-            '#attributes' => array(
-              'name'		=> 'Smart_Paging',
-              'content' => 'on',
-            ),
-            '#tag' => 'meta'
-          ), 'smart_paging_on');
-          // Call this function to register the additional html head
-          drupal_get_html_head();
         }
       }
     }
@@ -899,17 +914,47 @@ function smart_paging_field_attach_view_alter(&$build, $context) {
         drupal_add_js(drupal_get_path('module', 'smart_paging') . '/js/smart_paging-pager.js');
         drupal_add_js(array('smart_paging' => $pager_details), 'setting');
       }
+      //set up pager arguments.
+      $total_page_offset = $total_page - 1;
+      if ($enable_clean_url) {
+        $pager_prefix = $pager_details['path_prefix'] . '/' . $pager_details['first_element'];
+      }
+      else {
+        $pager_prefix = 'page=' . $pager_details['first_element'];
+      }
+      //Build url representation of current page. Using an absolute url allows outbound url hooks to modify the domain if necessary (domain module).
+      $current_absolute_alias = url($_GET['q'], array('absolute' => TRUE));
+      $url_suffix = array();
+      //Do we want nopaging as canonical instead of current page?
+      if (variable_get('smart_paging_use_nopaging_canonical', FALSE)) {
+        $link_current_page = $current_absolute_alias . '?nopaging=1';
+      }
+      //No. Make current paginated page canonical.
+      else {
+        if ($current_page == 0) {
+          // We are on first page
+          $link_current_page = $current_absolute_alias;
+        }
+        else{
+          $link_current_page = $enable_clean_url ? "$current_absolute_alias/$pager_prefix/" . $current_page : "$current_absolute_alias?$pager_prefix%2C" . $current_page;
+        }
+      }
+
+      //by default add a canonical head element here. We will clean up any duplicates in the hook.
+      drupal_add_html_head(array(
+              '#attributes' => array(
+              'rel'  => 'canonical',
+              'href' => $link_current_page,
+            ),
+            '#tag' => 'link',
+            '#attached' => array(
+                    'drupal_add_http_header' => array(array('Link', '<' . $link_current_page . '>; rel="canonical"', 1)),
+              ),
+          ), 'smart_paging_link_canonical');
 
       if (variable_get('smart_paging_use_link_rel', TRUE)) {
         // Pagination with rel="next" and rel="prev"
         // Ref: http://googlewebmastercentral.blogspot.co.uk/2011/09/pagination-with-relnext-and-relprev.html
-        $total_page_offset = $total_page - 1;
-        if ($enable_clean_url) {
-          $pager_prefix = $pager_details['path_prefix'] . '/' . $pager_details['first_element'];
-        }
-        else {
-          $pager_prefix = 'page=' . $pager_details['first_element'];
-        }
         if ($current_page == 0) {
           // We are on first page
           $link_rel_next_page = $enable_clean_url ? "$pager_prefix/1" : "$pager_prefix%2C1";
@@ -1010,34 +1055,49 @@ function smart_paging_field_attach_view_alter(&$build, $context) {
  */
 function smart_paging_html_head_alter(&$head_elements) {
   global $base_root;
-  if (isset($head_elements['smart_paging_on'])) {
-    // Set the single page view URL as canonical.
-    unset($head_elements['smart_paging_on']);
-    $url_components = parse_url($base_root);
-    $args = $_GET;
-    unset($args['q']);
-    $args['nopaging'] = 1;
-    $args = http_build_query($args);
-    $url_path = $url_components['host'] . '/' . request_path();
-    $canonical_link = $url_components['scheme'] . "://$url_path?$args";
+  if (isset($head_elements['smart_paging_link_canonical'])) {
+    //Process the canonical.
+    $smart_paging_canonical['smart_paging_link_canonical'] = $head_elements['smart_paging_link_canonical'];
+    unset($head_elements['smart_paging_link_canonical']);
+
+	$current_alias = function_exists("path_alias_xt_get_path_alias") ? path_alias_xt_get_path_alias($_GET['q']) : drupal_get_path_alias($_GET['q']);
+    $current_absolute_alias = url($_GET['q'], array('absolute' => TRUE));
+    $override_canonical = array();
+    //collect other existing canonical element(s)
     foreach ($head_elements as $head_element_key => $head_element) {
-      if (isset($head_element['#tag']) && $head_element['#tag'] == 'link' && isset($head_element['#attributes']) && $head_element['#attributes']['rel'] == 'canonical') {
-        $head_elements[$head_element_key]['#attributes']['href'] = $canonical_link;
-        $canonical_link = '';
-        break;
+      $canonical_tag = isset($head_element['#tag']) && $head_element['#tag'] == 'link' && isset($head_element['#attributes']) && $head_element['#attributes']['rel'] == 'canonical';
+      $canonical_metatag = $head_element_key == 'metatag_canonical';
+      //drupal standard canonical link style plus metatag edge case - does not overwrite standard drupal
+      if (strpos($head_element_key, 'drupal_add_html_head_link:canonical') === 0 || $canonical_tag || $canonical_metatag) {
+        //if other canonicals are different from the base url (page1), collect them.
+        //Check absolute url alias for page as well, this should allow Domain Source, or other absolute, provided canonical to be authoratative.
+        if (($canonical_tag && $head_element['#attributes']['href'] != $current_alias && $head_element['#attributes']['href'] != $current_absolute_alias) || ($canonical_metatag && $head_element['#value'] != $current_alias && $head_element['#value'] != $current_absolute_alias)) {
+          $override_canonical[$head_element_key] = $head_element;
+        }
+        unset($head_elements[$head_element_key]);
       }
     }
-    if (!empty($canonical_link)) {
-      $head_elements['canonical'] = array(
-        '#type' => 'html_tag',    
-        '#tag'  => 'link',    
-        '#attributes' => array(
-          'rel'  => 'canonical',
-          'href' => $canonical_link,
-        ), 
-      );
+    //If there are existing canonicals that don't match the base url, use them
+    //We are erring on the side that if another module is specifying a canonical different from this page's root (page1) then we shouldn't change it.
+    if (!empty($override_canonical)) {
+      $head_elements = array_merge($head_elements, $override_canonical);
+    }
+    //otherwise use the smart_paging canonical
+    else {
+      $head_elements = array_merge($head_elements, $smart_paging_canonical);
+	  //remove any other canonicals already in the http response
+	  //here we are assuming that if the canonicals in the <head> element are ok to override, so is the http header
+	  $http_header_link = drupal_get_http_header('Link');
+	  $http_header_link = explode(',', $http_header_link);
+	  foreach ($http_header_link as $key => $link) {
+	    if (preg_match('#rel="canonical"#i', $link)) {
+		  unset($http_header_link[$key]);
+		}
+	  }
+	  drupal_add_http_header('Link', implode(',', $http_header_link));
     }
   }
+  //Smart Paging SEO Processing.
   if (isset($head_elements['smart_paging_seo'])) {
     $smart_paging_seo = json_decode($head_elements['smart_paging_seo']['#attributes']['content']);
     $tags = array();
@@ -1655,4 +1715,36 @@ function smart_paging_entities() {
     'taxonomy_term',
   );
   return $entities;
-}
\ No newline at end of file
+}
+
+/**
+ * Implements hook_metatags_view_alter().
+ */
+function smart_paging_metatag_metatags_view_alter(&$output, $instance) {
+  // Load metatags set for this page.
+  $page_metatags = drupal_static('smart_paging');
+
+  if (!empty($page_metatags)) {
+    $metatags = array();
+    $output_metatags = array();
+    $options['instance'] = $instance;
+    // Rearrange the array so that we can use metatag module classes.
+    foreach ($page_metatags as $metatag => $value) {
+      if (isset($value) && !empty($value)) {
+      	$target_tag = explode('_', $metatag);
+        if (isset($target_tag[0]) && isset($target_tag[1]) && isset($target_tag[2]) && isset($target_tag[3])) {
+          $metatags[$target_tag[2]] = array('value' => $value);
+        }
+      }
+    }
+    // Create objects for each metatag so that we get all required information.
+    foreach ($metatags as $metatag => $data) {
+      if ($metatag_instance = metatag_get_instance($metatag, $data)) {
+        $output_metatags[$metatag] = $metatag_instance->getElement($options);
+      }
+    }
+
+    // Merge with metatags provided by other modules.
+    $output = array_merge($output, $output_metatags);
+  }
+}
